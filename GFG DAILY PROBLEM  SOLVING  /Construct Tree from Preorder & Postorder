class Solution:

    def constructTreeUtil(self, pre, post, preIndex, l, h, size, postIndexMap):
        if preIndex[0] >= size or l > h:
            return None

        # Create root node
        root = Node(pre[preIndex[0]])
        preIndex[0] += 1

        # If only one node in this subtree
        if l == h or preIndex[0] >= size:
            return root

        # Find the index of the next preorder element in postorder
        i = postIndexMap[pre[preIndex[0]]]

        # Build left and right subtrees
        if i <= h:
            root.left = self.constructTreeUtil(pre, post, preIndex, l, i, size,
                                               postIndexMap)
            root.right = self.constructTreeUtil(pre, post, preIndex, i + 1,
                                                h - 1, size, postIndexMap)

        return root

    def constructTree(self, pre, post):
        size = len(pre)
        preIndex = [0]

        postIndexMap = {val: idx for idx, val in enumerate(post)}

        return self.constructTreeUtil(pre, post, preIndex, 0, size - 1, size,
                                      postIndexMap)
