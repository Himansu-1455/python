
class Solution:
    # Recursive function to find all valid combinations
    def findCombinations(self, n, k, subVector, res, last):

        # Base case: if exact sum and exact count achieved
        if n == 0 and k == 0:
            res.append(subVector[:])
            return

        # If sum or count becomes negative, backtrack
        if n < 0 or k < 0:
            return

        # Try numbers from 'last' to 9
        for i in range(last, 10):

            # Choose the number
            subVector.append(i)
            self.findCombinations(n - i, k - 1, subVector, res, i + 1)

            # Backtrack
            subVector.pop()

    def combinationSum(self, n, k):
        # Check if combination is impossible
        if n < k or n > 9 * k:
            return []

        subVector = []
        res = []

        self.findCombinations(n, k, subVector, res, 1)
        return res
